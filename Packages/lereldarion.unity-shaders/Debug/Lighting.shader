// Made by Lereldarion (https://github.com/lereldarion/unity-shaders)
// Free to redistribute under the MIT license

// Debug view for lighting metadata by generating 3D gizmos.
// Runs on a mesh with at least one point, all gizmos are generated by geometry passes.
// 
// Unity gizmos use solid lines :
// - Directional lights : directional arrow, in front of camera. Color is light color.
// - Pixel point lights : 14 rays from light center (axis-aligned + diagonals). Color is light color.
// - Vertex point lights : 6 rays from light center (axis-aligned). Color is light color.
// - Spot light : cone boundary as octagonal pyramid. Color is light color.
// - Light probes : indirect diffuse shading on a sphere in front of camera.
// - Reflection probes : solid boundary boxes, and dashed lines towards probe position. White/grey depending on blending. Raw texture displayed on a sphere.
// 
// REDSIM VRC Light Volumes (V2.0) use dashed lines with less complexity :
// - Light volumes as dashed boxes. Dash size is the texture resolution for each volume. Color is item index.
// - Point light : 6 axis-aligned dashed lines. Lines lengths are the culling distance (dash size = 1m). Color is reconstructed hue. Show a probe sphere with cubemap if used.
// - Spot light : 4 cone dashed edges. Lines lengths are the culling distance (dash size = 1m). Color is reconstructed hue. Show a probe sphere with cookie if used.
// - Area light : rectangle with solid edges. Dashed normal vector, length is culling distance (dash size = 1m). Color is reconstructed hue.
// 
// LTCGI : emitting surfacePoints as rectangle edges + diagonals. A normal line at center. Solid lines. Color is item index.

Shader "Lereldarion/Debug/Lighting" {
    Properties {
        _Distance_Limit ("Enable visuals only if distance object-camera is lower than this threshold", Float) = 10
        _ViewSpace_Anchor ("View space anchor point for some items", Vector) = (0, 0, -1.5, 0)
        
        [Header(Gizmos sizes)]
        _LightProbe_Radius ("Light Probe sphere radius", Float) = 0.05
        _ReflectionProbe_Radius ("Reflection Probe sphere radius", Float) = 0.2
        _Light_Radius ("Radius of light center gizmos (sphere cookie, octahedron, ...)", Float) = 0.2
    }
    SubShader {
        Tags {
            "Queue" = "Overlay"
            "RenderType" = "Overlay"
            "VRCFallback" = "Hidden"
            "PreviewType" = "Plane"
        }

        CGINCLUDE
        #pragma target 5.0

        #include "UnityCG.cginc"
        #include "UnityLightingCommon.cginc"
        #include "AutoLight.cginc"

        uniform float _VRChatMirrorMode;
        uniform float3 _ViewSpace_Anchor;
        uniform float _Distance_Limit;
        uniform float _LightProbe_Radius;
        uniform float _ReflectionProbe_Radius;
        uniform float _Light_Radius;

        ///////////////////////////////////////////////////////////////////////
        // Structs

        struct MeshData {
            UNITY_VERTEX_INPUT_INSTANCE_ID
        };
        
        struct LinePoint {
            float4 position : SV_POSITION;
            half3 color : LINE_COLOR;
            float dash : DASH;
            UNITY_VERTEX_OUTPUT_STEREO
        };

        struct Sphere {
            float4 position : SV_POSITION;
            float3 normal : NORMAL_UVW;
            float spot_tan_angle : SPOT_TAN_ANGLE;
            nointerpolation uint mode : MODE; // 0 = LightProbe, 1 = SpecCube0, 2 = SpecCube1, 3|(id<<3) = LV spot light cookie, 4|(id<<3) = LV point light cubemap
            UNITY_VERTEX_OUTPUT_STEREO
        };

        ///////////////////////////////////////////////////////////////////////
        // Utils

        #if defined(USING_STEREO_MATRICES)
        static float3 centered_camera_ws = (unity_StereoWorldSpaceCameraPos[0] + unity_StereoWorldSpaceCameraPos[1]) / 2;
        #else
        static float3 centered_camera_ws = _WorldSpaceCameraPos.xyz;
        #endif

        float length_sq(float3 v) { return dot(v, v); }
        half length_sq(half3 v) { return dot(v, v); }

        float3x3 referential_from_z(float3 z) {
            z = normalize(z);
            float3 x = cross(z, float3(0, 1, 0)); // Cross with world up for the sides
            if(length_sq(x) == 0) {
                x = float3(1, 0, 0); // Fallback if aligned
            } else {
                x = normalize(x);
            }
            float3 y = cross(x, z);
            return float3x3(x, y, z);
        }

        float3x3 quaternion_to_matrix(float4 q) {
            float3 a = float3(-1, 1, 1);
            float3x3 identity = float3x3(1, 0, 0, 0, 1, 0, 0, 0, 1); 
            float3 u = q.zyz * a * q.w, v = q.xyx * a.xxy * q.w;
            float3x3 m = float3x3(0, u.x, u.y, u.z, 0, v.x, v.y, v.z, 0) + 0.5 * identity + float3x3(q.xyz * q.x, q.xyz * q.y, q.xyz * q.z) * (1.0 - identity);
            q *= q;
            m -= float3x3(q.y + q.z, 0, 0, 0, q.x + q.z, 0, 0, 0, q.x + q.y);
            return m * 2.0;
        }
        float3 LV_MultiplyVectorByQuaternion(float3 v, float4 q) {
            float3 t = 2.0 * cross(q.xyz, v);
            return v + q.w * t + cross(q.xyz, t);
        }

        // math adapted from https://gist.github.com/mairod/a75e7b44f68110e1576d77419d608786?permalink_comment_id=3180018#gistcomment-3180018
        // rotates in YIQ color space for efficiency
        half3 hue_shift_yiq(const half3 col, const half hueAngle) {
            const half3 k = 0.57735;
            const half sinAngle = sin(hueAngle);
            const half cosAngle = cos(hueAngle);
            return col * cosAngle + cross(k, col) * sinAngle + k * dot(k, col) * (1.0 - cosAngle);
        }

        float4x4 inverse(float4x4 mat) {
            // by lox9973
            float4x4 M=transpose(mat);
            float m01xy=M[0].x*M[1].y-M[0].y*M[1].x;
            float m01xz=M[0].x*M[1].z-M[0].z*M[1].x;
            float m01xw=M[0].x*M[1].w-M[0].w*M[1].x;
            float m01yz=M[0].y*M[1].z-M[0].z*M[1].y;
            float m01yw=M[0].y*M[1].w-M[0].w*M[1].y;
            float m01zw=M[0].z*M[1].w-M[0].w*M[1].z;
            float m23xy=M[2].x*M[3].y-M[2].y*M[3].x;
            float m23xz=M[2].x*M[3].z-M[2].z*M[3].x;
            float m23xw=M[2].x*M[3].w-M[2].w*M[3].x;
            float m23yz=M[2].y*M[3].z-M[2].z*M[3].y;
            float m23yw=M[2].y*M[3].w-M[2].w*M[3].y;
            float m23zw=M[2].z*M[3].w-M[2].w*M[3].z;
            float4 adjM0,adjM1,adjM2,adjM3;
            adjM0.x=+dot(M[1].yzw,float3(m23zw,-m23yw,m23yz));
            adjM0.y=-dot(M[0].yzw,float3(m23zw,-m23yw,m23yz));
            adjM0.z=+dot(M[3].yzw,float3(m01zw,-m01yw,m01yz));
            adjM0.w=-dot(M[2].yzw,float3(m01zw,-m01yw,m01yz));
            adjM1.x=-dot(M[1].xzw,float3(m23zw,-m23xw,m23xz));
            adjM1.y=+dot(M[0].xzw,float3(m23zw,-m23xw,m23xz));
            adjM1.z=-dot(M[3].xzw,float3(m01zw,-m01xw,m01xz));
            adjM1.w=+dot(M[2].xzw,float3(m01zw,-m01xw,m01xz));
            adjM2.x=+dot(M[1].xyw,float3(m23yw,-m23xw,m23xy));
            adjM2.y=-dot(M[0].xyw,float3(m23yw,-m23xw,m23xy));
            adjM2.z=+dot(M[3].xyw,float3(m01yw,-m01xw,m01xy));
            adjM2.w=-dot(M[2].xyw,float3(m01yw,-m01xw,m01xy));
            adjM3.x=-dot(M[1].xyz,float3(m23yz,-m23xz,m23xy));
            adjM3.y=+dot(M[0].xyz,float3(m23yz,-m23xz,m23xy));
            adjM3.z=-dot(M[3].xyz,float3(m01yz,-m01xz,m01xy));
            adjM3.w=+dot(M[2].xyz,float3(m01yz,-m01xz,m01xy));
            float invDet=rcp(dot(M[0].xyzw,float4(adjM0.x,adjM1.x,adjM2.x,adjM3.x)));
            return transpose(float4x4(adjM0*invDet,adjM1*invDet,adjM2*invDet,adjM3*invDet));
        }

        float3 item_anchor_point_ws() {
            // A point in front of the camera to attach items such as directional light vector, lightprobe values...
            return centered_camera_ws + mul((float3x3) unity_MatrixInvV, _ViewSpace_Anchor);
        }

        bool within_distance_limit() {
            float3 object_ws = mul(unity_ObjectToWorld, float4(0, 0, 0, 1)).xyz;
            return length_sq(object_ws - centered_camera_ws) <= _Distance_Limit * _Distance_Limit;
        }

        ///////////////////////////////////////////////////////////////////////
        // Drawing

        struct LineDrawer {
            LinePoint output;

            static LineDrawer init(half3 color) {
                LineDrawer drawer;
                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(drawer.output);
                drawer.output.color = color;
                drawer.output.dash = 0;
                return drawer;
            }

            void init_cs(inout LineStream<LinePoint> stream, float4 position_cs, float dash_offset = 0) {
                output.dash = dash_offset;
                output.position = position_cs;
                stream.RestartStrip();
                stream.Append(output);
            }
            void init_ws(inout LineStream<LinePoint> stream, float3 position_ws, float dash_offset = 0) {
                init_cs(stream, UnityWorldToClipPos(position_ws), dash_offset);
            }

            void solid_cs(inout LineStream<LinePoint> stream, float4 position_cs) {
                output.position = position_cs;
                stream.Append(output);
            }
            void solid_ws(inout LineStream<LinePoint> stream, float3 position_ws) {
                solid_cs(stream, UnityWorldToClipPos(position_ws));
            }

            void dashed_cs(inout LineStream<LinePoint> stream, float4 position_cs, float dashes) {
                output.dash += dashes;
                output.position = position_cs;
                stream.Append(output);
            }
            void dashed_ws(inout LineStream<LinePoint> stream, float3 position_ws, float dashes) {
                dashed_cs(stream, UnityWorldToClipPos(position_ws), dashes);
            }
        };

        ///////////////////////////////////////////////////////////////////////
        // Unity lighting gizmos

        void unity_directional_light(inout LineStream<LinePoint> s, half3 color, float3 light_forward_ws) {
            LineDrawer drawer = LineDrawer::init(color); // 10 calls
            float3x3 referential = referential_from_z(light_forward_ws);

            // Line to an arbitrary point in front of the camera (directional lights are infinite)
            float3 target = item_anchor_point_ws();
            float3 origin = target - 0.5 * referential[2];
            float4 origin_cs = UnityWorldToClipPos(origin);
            drawer.init_ws(s, target); drawer.solid_cs(s, origin_cs);

            // Tetrahedron on origin.
            float size = 0.05;
            float4 tetrahedron_a = UnityWorldToClipPos(origin + mul(size * float3(0, 1, -1.5), referential));
            float4 tetrahedron_b = UnityWorldToClipPos(origin + mul(size * float3(0.86, -0.5, -1.5), referential));
            float4 tetrahedron_c = UnityWorldToClipPos(origin + mul(size * float3(-0.86, -0.5, -1.5), referential));
            drawer.solid_cs(s, tetrahedron_a); drawer.solid_cs(s, tetrahedron_b);
            drawer.init_cs(s, origin_cs); drawer.solid_cs(s, tetrahedron_b); drawer.solid_cs(s, tetrahedron_c);
            drawer.init_cs(s, origin_cs); drawer.solid_cs(s, tetrahedron_c); drawer.solid_cs(s, tetrahedron_a);
        }

        void unity_pixel_point_light(inout LineStream<LinePoint> s, half3 color, float3 pos, float4x4 world_to_light) {
            LineDrawer drawer = LineDrawer::init(color); // 14 calls
            
            // Pixel point light : world to light is a nice matrix with rotation + scale + translation.
            // Only use inverse for scale + rotation, as we have the center separately. Cheaper 70 math vs 78 math.
            float3x3 light_to_world = (float3x3) inverse(world_to_light);

            // Axis aligned rays
            drawer.init_ws(s, pos + mul(light_to_world, float3(-1,  0,  0))); drawer.solid_ws(s, pos + mul(light_to_world, float3(1, 0, 0)));
            drawer.init_ws(s, pos + mul(light_to_world, float3( 0, -1,  0))); drawer.solid_ws(s, pos + mul(light_to_world, float3(0, 1, 0)));
            drawer.init_ws(s, pos + mul(light_to_world, float3( 0,  0, -1))); drawer.solid_ws(s, pos + mul(light_to_world, float3(0, 0, 1)));
            // Diagonal rays
            float c = 1. / sqrt(3.);
            drawer.init_ws(s, pos + mul(light_to_world, float3(-c, -c, -c))); drawer.solid_ws(s, pos + mul(light_to_world, float3( c,  c,  c)));
            drawer.init_ws(s, pos + mul(light_to_world, float3( c, -c, -c))); drawer.solid_ws(s, pos + mul(light_to_world, float3(-c,  c,  c)));
            drawer.init_ws(s, pos + mul(light_to_world, float3(-c,  c, -c))); drawer.solid_ws(s, pos + mul(light_to_world, float3( c, -c,  c)));
            drawer.init_ws(s, pos + mul(light_to_world, float3(-c, -c,  c))); drawer.solid_ws(s, pos + mul(light_to_world, float3( c,  c, -c)));
        }

        void instanced_unity_vertex_point_light(inout LineStream<LinePoint> s, uint instance_0_6, half3 color, float3 pos, float attenuation) {
            LineDrawer drawer = LineDrawer::init(color); // 4 calls
            
            const float range = 5.0 * rsqrt(attenuation); // https://discussions.unity.com/t/point-light-in-v-f-shader/679554/10 Pema

            // Draw a central octahedron and 6 axis-aligned rays from each corner.
            const uint instance_0_3 = instance_0_6 >= 3 ? instance_0_6 - 3 : instance_0_6;
            const float direction = instance_0_6 >= 3 ? -1 : 1;
            float3 axis_x = uint3(0, 1, 2) == instance_0_3 ? direction : 0;
            float3 axis_y = uint3(2, 0, 1) == instance_0_3 ? direction : 0;
            drawer.init_ws(s, pos - axis_x * _Light_Radius);
            drawer.solid_ws(s, pos + axis_y * _Light_Radius);
            drawer.solid_ws(s, pos + axis_x * _Light_Radius);
            drawer.solid_ws(s, pos + axis_x * range);
        }

        void unity_spot_light(inout LineStream<LinePoint> s, half3 color, float3 pos, float4x4 world_to_light) {
            LineDrawer drawer = LineDrawer::init(color); // 20 vertexcount

            // W2L * (W.xyz, 1) = L.xyzw
            // From AutoLight.cginc : the light cone is defined by uv.xy=L.xy/L.w in [-0.5, 0.5] and L.z in [0, 1]
            // W2L.012 * W.xyz = (uv.xy * L.w, L.zw) - W2L.3 = L.w * (uv.xy, 0, 1) + (0, 0, L.z, 0) - W2L.3
            // [W2L.012|(-uv.xy, 0, -1)] * (W.xyz, L.w) = (0, 0, L.z, 0) - W2L.3
            const float4 w2l_3 = world_to_light._m03_m13_m23_m33;

            // L = (0, 0, 1)
            world_to_light._m03_m13_m23_m33 = float4(0, 0, 0, -1);
            float3 L001_ws = mul(inverse(world_to_light), float4(0, 0, 1, 0) - w2l_3).xyz;
            // +x : L = (0.5, 0, 1)
            world_to_light._m03_m13_m23_m33 = float4(0.5, 0, 0, -1);
            float3 Lx_ws = mul(inverse(world_to_light), float4(0, 0, 1, 0) - w2l_3).xyz - L001_ws;
            // +y : L = (0, 0.5, 1)
            world_to_light._m03_m13_m23_m33 = float4(0, 0.5, 0, -1);
            float3 Ly_ws = mul(inverse(world_to_light), float4(0, 0, 1, 0) - w2l_3).xyz - L001_ws;

            // Cone
            float4 cone_point_cs = UnityWorldToClipPos(pos);
            float4 cone_base_cs[8];
            [unroll] for(uint i = 0; i < 8; i += 1) {
                float2 scale;
                sincos(i * UNITY_TWO_PI / 8, scale.x, scale.y);
                cone_base_cs[i] = UnityWorldToClipPos(L001_ws + scale.x * Lx_ws + scale.y * Ly_ws);
            }
            for(i = 0; i < 8; i += 2) {
                drawer.init_cs(s, cone_base_cs[i + 1]); drawer.solid_cs(s, cone_base_cs[i]);
                drawer.solid_cs(s, cone_point_cs); drawer.solid_cs(s, cone_base_cs[i + 1]);
                drawer.solid_cs(s, cone_base_cs[(i + 2) % 8]);
            }
        }

        void unity_reflection_probe(inout LineStream<LinePoint> s, half3 color, float3 position_ws, float3 bbox_min, float3 bbox_max) {
            LineDrawer drawer = LineDrawer::init(color); // 21 calls
            // With no defined reflection boxes, unity will use the skybox with infinite bounding boxes.
            bool is_skybox = any(!isfinite(bbox_min));
            if(is_skybox) {
                bbox_min = position_ws - _Distance_Limit;
                bbox_max = position_ws + _Distance_Limit;
            }
            // Precompute center and 8 corners (x = +1, y = +2, z = +4)
            float4 center = UnityWorldToClipPos(position_ws);
            float dashes[8];
            float4 corners[8];
            for(uint i = 0; i < 8; i += 1) {
                float3 corner = i & uint3(1, 2, 4) ? bbox_max : bbox_min;
                dashes[i] = 10 * round(distance(corner, position_ws));
                corners[i] = UnityWorldToClipPos(corner);
            }
            // Drawing
            if(!is_skybox) {
                // Draw cube and lines from corner to center. In one big line.
                drawer.init_cs(s, center);
                drawer.dashed_cs(s, corners[0], dashes[0]); drawer.solid_cs(s, corners[1]); drawer.solid_cs(s, corners[5]); drawer.solid_cs(s, corners[4]); drawer.dashed_cs(s, center, dashes[4]);
                drawer.dashed_cs(s, corners[1], dashes[1]); drawer.solid_cs(s, corners[3]); drawer.solid_cs(s, corners[7]); drawer.solid_cs(s, corners[5]); drawer.dashed_cs(s, center, dashes[5]);
                drawer.dashed_cs(s, corners[3], dashes[3]); drawer.solid_cs(s, corners[2]); drawer.solid_cs(s, corners[6]); drawer.solid_cs(s, corners[7]); drawer.dashed_cs(s, center, dashes[7]);
                drawer.dashed_cs(s, corners[2], dashes[2]); drawer.solid_cs(s, corners[0]); drawer.solid_cs(s, corners[4]); drawer.solid_cs(s, corners[6]); drawer.dashed_cs(s, center, dashes[6]);
            } else {
                // Just draw corner-center lines
                drawer.init_cs(s, corners[0]); drawer.dashed_cs(s, corners[7], dashes[0] + dashes[7]);
                drawer.init_cs(s, corners[1]); drawer.dashed_cs(s, corners[6], dashes[1] + dashes[6]);
                drawer.init_cs(s, corners[2]); drawer.dashed_cs(s, corners[5], dashes[2] + dashes[5]);
                drawer.init_cs(s, corners[3]); drawer.dashed_cs(s, corners[4], dashes[3] + dashes[4]);
            }
        }
        
        ///////////////////////////////////////////////////////////////////////
        // VRC Light Volumes https://github.com/REDSIM/VRCLightVolumes/

        uniform float _UdonLightVolumeCount; // All volumes count in scene, max 32
        uniform Texture3D _UdonLightVolume; // Main 3D Texture atlas
        uniform float4x4 _UdonLightVolumeInvWorldMatrix[32]; // World to Local (-0.5, 0.5) UVW Matrix
        uniform float3 _UdonLightVolumeUvw[32 * 6]; // AABB Bounds of islands on the 3D Texture atlas

        void draw_vrc_light_volume_boxes(inout LineStream<LinePoint> s, uint volume_id) {            
            // Select a color for the volume ; hue shift gradient from red.
            half3 color = hue_shift_yiq(half3(1, 0, 0), volume_id / _UdonLightVolumeCount * UNITY_TWO_PI);
            LineDrawer drawer = LineDrawer::init(color); // 20 calls
            
            // Project bounds to CS
            float4x4 volume_to_world = inverse(_UdonLightVolumeInvWorldMatrix[volume_id]);
            float4x4 volume_to_cs = mul(UNITY_MATRIX_VP, volume_to_world);
            float4 corners[8];
            for(uint i = 0; i < 8; i += 1) {
                float3 corner = i & uint3(1, 2, 4) ? -0.5 : 0.5;
                corners[i] = mul(volume_to_cs, float4(corner, 1));
            }
            
            // Texel resolution as dash count
            float3 atlas_texels;
            _UdonLightVolume.GetDimensions(atlas_texels.x, atlas_texels.y, atlas_texels.z);
            uint uvwID = volume_id * 6;
            float3 uvw_resolution = _UdonLightVolumeUvw[uvwID + 1].xyz - _UdonLightVolumeUvw[uvwID].xyz;
            float3 texels = atlas_texels * uvw_resolution; // should be integers
            
            // Draw edges with texel count
            drawer.init_cs(s, corners[0]); drawer.dashed_cs(s, corners[1], texels.x); drawer.dashed_cs(s, corners[5], texels.z); drawer.dashed_cs(s, corners[4], texels.x);
            drawer.init_cs(s, corners[1]); drawer.dashed_cs(s, corners[3], texels.y); drawer.dashed_cs(s, corners[7], texels.z); drawer.dashed_cs(s, corners[5], texels.y);
            drawer.init_cs(s, corners[3]); drawer.dashed_cs(s, corners[2], texels.x); drawer.dashed_cs(s, corners[6], texels.z); drawer.dashed_cs(s, corners[7], texels.x);
            drawer.init_cs(s, corners[2]); drawer.dashed_cs(s, corners[0], texels.y); drawer.dashed_cs(s, corners[4], texels.z); drawer.dashed_cs(s, corners[6], texels.y);
        }

        uniform float _UdonPointLightVolumeCount; // Point Lights count, max 128
        uniform float4 _UdonPointLightVolumePosition[128]; // XYZ = Position. W = Inverse squared range (point light) | Inverse squared range, negated (spot light) | Width (area light)
        uniform float4 _UdonPointLightVolumeColor[128]; // XYZ = Color. W = Cos of angle for LUT (point light) | Cos of outer angle if no custom texture, tan of outer angle otherwise (spot light) | 2 + Height (area light) 
        uniform float4 _UdonPointLightVolumeDirection[128]; // Rotation quaternion (point light, area light, cookie spot light) | XYZ direction + W cone falloff (analytic spot light)
        uniform float3 _UdonPointLightVolumeCustomID[128]; // X = 0 if analytic, -cookie_ID, or +custom_lut_ID. Y shadow mask id. Z squared culling distance.

        void draw_vrc_light_volume_light(inout LineStream<LinePoint> s, uint light_id) {
            const float3 custom_id_data = _UdonPointLightVolumeCustomID[light_id];
            const float4 position = _UdonPointLightVolumePosition[light_id];
            const float4 color = _UdonPointLightVolumeColor[light_id];
            const float4 direction_or_rotation = _UdonPointLightVolumeDirection[light_id];
            
            const float culling_distance = sqrt(custom_id_data.z); // generally radius of sphere / spotlight cone
            float3x3 referential = quaternion_to_matrix(direction_or_rotation);

            float intensity = max(color.r, max(color.g, color.b)); // Fix premultiplication by intensity. Will not retrieve component color, but at least the hue should be ok.
            LineDrawer drawer = LineDrawer::init(color.rgb / intensity);
            
            // Select mode code from LightVolumes.cginc
            [branch] if(position.w < 0) {
                // spot light : 6 vertex count
                float2 sin_cos_size;
                if(custom_id_data.x >= 0) {
                    // No cookie. Analytical light with no specific rotation, so align to vertical.
                    referential = referential_from_z(direction_or_rotation.xyz);
                    // color.w is cos angle
                    sin_cos_size = float2(sqrt(1 - color.w * color.w), color.w);
                } else {
                    // color.w is tan angle
                    float cos = 1/sqrt(1 + color.w * color.w);
                    sin_cos_size = float2(color.w * cos, cos);
                }
                sin_cos_size *= culling_distance;

                // Cone with 4 lines, dashed to indicate culling_distance
                float4 position_cs = UnityWorldToClipPos(position.xyz);
                drawer.init_ws(s, position.xyz + mul(float3(-sin_cos_size.x, 0, sin_cos_size.y), referential), culling_distance);
                drawer.dashed_cs(s, position_cs, -culling_distance);
                drawer.dashed_ws(s, position.xyz + mul(float3(sin_cos_size.x, 0, sin_cos_size.y), referential), culling_distance);
                drawer.init_ws(s, position.xyz + mul(float3(0, -sin_cos_size.x, sin_cos_size.y), referential), culling_distance);
                drawer.dashed_cs(s, position_cs, -culling_distance);
                drawer.dashed_ws(s, position.xyz + mul(float3(0, sin_cos_size.x, sin_cos_size.y), referential), culling_distance);
            } else if (color.w <= 1.5f) {
                // point light : 6 vertex count
                // rotation quaternion is not updated if no cookie, fine by me
                
                // axis aligned 3 lines with dashes for culling distance
                drawer.init_ws(s, position.xyz + mul(float3(-culling_distance, 0, 0), referential), -culling_distance);
                drawer.dashed_ws(s, position.xyz + mul(float3(culling_distance, 0, 0), referential), 2 * culling_distance);
                drawer.init_ws(s, position.xyz + mul(float3(0, -culling_distance, 0), referential), -culling_distance);
                drawer.dashed_ws(s, position.xyz + mul(float3(0, culling_distance, 0), referential), 2 * culling_distance);
                drawer.init_ws(s, position.xyz + mul(float3(0, 0, -culling_distance), referential), -culling_distance);
                drawer.dashed_ws(s, position.xyz + mul(float3(0, 0, culling_distance), referential), 2 * culling_distance);
            } else {
                // area light : 7 vertex count
                // For some reason the referential matrix is inverse of the others. Whatever...
                float2 size = 0.5 * float2(position.w, color.w - 2.0f);
                
                // Quad outline
                const float4 init_position_cs = UnityWorldToClipPos(position.xyz + mul(referential, float3(-size.x, -size.y, 0)));
                drawer.init_cs(s, init_position_cs);
                drawer.solid_ws(s, position.xyz + mul(referential, float3(size.x, -size.y, 0)));
                drawer.solid_ws(s, position.xyz + mul(referential, float3(size.x, size.y, 0)));
                drawer.solid_ws(s, position.xyz + mul(referential, float3(-size.x, size.y, 0)));
                drawer.solid_cs(s, init_position_cs);

                // Dashed normal sized to culling_distance
                drawer.init_ws(s, position.xyz);
                drawer.dashed_ws(s, position.xyz + mul(referential, float3(0, 0, culling_distance)), culling_distance);
            }
        }

        ///////////////////////////////////////////////////////////////////////
        // LTCGI https://github.com/PiMaker/ltcgi/

        uniform uint _Udon_LTCGI_ScreenCount; // Up to 16
        uniform bool _Udon_LTCGI_Mask[16];
        uniform float4 _Udon_LTCGI_Vertices_0[16];
        uniform float4 _Udon_LTCGI_Vertices_1[16];
        uniform float4 _Udon_LTCGI_Vertices_2[16];
        uniform float4 _Udon_LTCGI_Vertices_3[16];

        void draw_ltcgi_surface(inout LineStream<LinePoint> s, uint screen_id) {
            if(!(screen_id < min(_Udon_LTCGI_ScreenCount, 16) && !_Udon_LTCGI_Mask[screen_id])) { return; }

            // Select a color for the volume ; hue shift gradient from red.
            half3 color = hue_shift_yiq(half3(1, 0, 0), (screen_id * UNITY_TWO_PI) / _Udon_LTCGI_ScreenCount);
            LineDrawer drawer = LineDrawer::init(color); // 10 calls

            float3 v0 = _Udon_LTCGI_Vertices_0[screen_id].xyz;
            float3 v1 = _Udon_LTCGI_Vertices_1[screen_id].xyz;
            float3 v2 = _Udon_LTCGI_Vertices_2[screen_id].xyz;
            float3 v3 = _Udon_LTCGI_Vertices_3[screen_id].xyz;

            // Alternate way to get positions. Both works.
            // Rotating screens on Pi's map are stuck not rotating in both modes...
            // uniform Texture2D<float4> _Udon_LTCGI_static_uniforms;
            // float3 v0 = _Udon_LTCGI_static_uniforms[uint2(0, screen_id)].xyz;
            // float3 v1 = _Udon_LTCGI_static_uniforms[uint2(1, screen_id)].xyz;
            // float3 v2 = _Udon_LTCGI_static_uniforms[uint2(2, screen_id)].xyz;
            // float3 v3 = _Udon_LTCGI_static_uniforms[uint2(3, screen_id)].xyz;

            float3 center = (v0 + v1 + v2 + v3) / 4;
            float3 normal = normalize(cross(v1 - v0, v2 - v0)) * -1; // -1 = cross is defined for vector from geom to screen
            float4 v0_cs = UnityWorldToClipPos(v0);
            float4 v1_cs = UnityWorldToClipPos(v1);
            float4 v2_cs = UnityWorldToClipPos(v2);
            float4 v3_cs = UnityWorldToClipPos(v3);

            // Rectangle + diagonals
            drawer.init_cs(s, v0_cs); drawer.solid_cs(s, v1_cs); drawer.solid_cs(s, v2_cs); drawer.solid_cs(s, v3_cs); // N
            drawer.init_cs(s, v1_cs); drawer.solid_cs(s, v3_cs); drawer.solid_cs(s, v0_cs); drawer.solid_cs(s, v2_cs); // Z
            drawer.init_ws(s, center); drawer.solid_ws(s, center + normal * length(v0 - center)); // Normal vector
        }

        ///////////////////////////////////////////////////////////////////////
        // Stages for line gizmos

        void vertex_stage (MeshData input, out MeshData output) {
            output = input;
        }

        void dash_discard(float t) {
            // Dashing : line and voids of length 1 along dash dimension
            float dash_01 = frac(abs(t) * 0.5); // abs to allow [-x, x] line to be symmetric
            if (dash_01 > 0.5 && dash_01 < 0.99) { discard; }
        }
        half4 fragment_lines_visible (LinePoint line_point) : SV_Target {
            UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(line_point);
            dash_discard(line_point.dash);
            return half4(line_point.color, 1);
        }
        half4 fragment_lines_occluded (LinePoint line_point) : SV_Target {
            UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(line_point);
            dash_discard(line_point.dash);
            return half4(line_point.color, 0.1);
        }

        [instance(32)]
        [maxvertexcount(20 /*lv box*/ + 8 * 7 /*lv lights*/ + 4 /*vertex light*/ + 21 /*max(LTCGI, builtin)*/)] // Manually set from logic vertexcounts below
        void geometry_lines_base(point MeshData input[1], uint primitive_id : SV_PrimitiveID, uint instance : SV_GSInstanceID, inout LineStream<LinePoint> stream) {
            UNITY_SETUP_INSTANCE_ID(input[0]);

            if (!(_VRChatMirrorMode == 0 && primitive_id == 0 && within_distance_limit())) { return; }

            // Always try to spread items on all threads if possible

            // LV boxes : 32 Volumes, 1 per instance.
            if(instance < min((uint) _UdonLightVolumeCount, 32)) {
                draw_vrc_light_volume_boxes(stream, instance); // 20 vertex
            }

            // LV lights : 128 lights, 8 per instances (x32 = 128) by parallel batches of 32.
            // A batch can have heterogeneous types, but I cannot know their types in advance.
            uint point_light_volume_count = min((uint) _UdonPointLightVolumeCount, 128);
            [loop] for(uint light_id = instance; light_id < point_light_volume_count; light_id += 32) {
                draw_vrc_light_volume_light(stream, light_id); // up to 7 vertex
            }

            // 4 Vertex point lights, instanced to 6x4=24 threads
            if(instance < 24) {
                uint vertex_light_id = instance / 6;
                uint instance_0_6 = instance - 6 * vertex_light_id;
                half3 color = unity_LightColor[vertex_light_id].rgb;
                if(any(color > 0)) {
                    float3 position = float3(unity_4LightPosX0[vertex_light_id], unity_4LightPosY0[vertex_light_id], unity_4LightPosZ0[vertex_light_id]);
                    instanced_unity_vertex_point_light(stream, instance_0_6, color, position, unity_4LightAtten0[vertex_light_id]); // 4 vertex
                }
            }

            // 16 Screens, 1 per instance for first 16.
            draw_ltcgi_surface(stream, instance); // 10 vertex

            // Spread remaining stuff vertex count on last threads. They are likely to use less vertex count.
            // Does not fix divergence.
            [forcecase]
            switch (instance) {
                case 31: {
                    // Main directional light, which may be disabled
                    float3 light_forward_ws = -_WorldSpaceLightPos0.xyz;
                    if(length_sq(light_forward_ws) > 0) {
                        unity_directional_light(stream, _LightColor0.rgb, light_forward_ws); // 10 vertex
                    }
                    break;
                }
                case 30: case 29: {
                    // Reflection probes : 21 vertex
                    bool is_primary = instance == 30;
                    #if defined(UNITY_SPECCUBE_BLENDING) || defined(FORCE_BOX_PROJECTION)
                    float blend_factor = is_primary ? unity_SpecCube0_BoxMin.w : 1 - unity_SpecCube0_BoxMin.w;
                    #else
                    float blend_factor = is_primary ? 1 : 0;
                    #endif
                    float3 position = is_primary ? unity_SpecCube0_ProbePosition.xyz : unity_SpecCube1_ProbePosition.xyz;
                    float3 bbox_min = is_primary ? unity_SpecCube0_BoxMin.xyz : unity_SpecCube1_BoxMin.xyz;
                    float3 bbox_max = is_primary ? unity_SpecCube0_BoxMax.xyz : unity_SpecCube1_BoxMax.xyz;
                    if (blend_factor > 0.00001) {
                        unity_reflection_probe(stream, blend_factor.xxx, position, bbox_min, bbox_max); // 21 vertex
                    }
                    break;
                }
                default: break;
            }
        }

        [maxvertexcount(20)]
        void geometry_lines_add(point MeshData input[1], uint primitive_id : SV_PrimitiveID, inout LineStream<LinePoint> stream) {
            UNITY_SETUP_INSTANCE_ID(input[0]);
            
            if (!(_VRChatMirrorMode == 0 && primitive_id == 0 && within_distance_limit())) { return; }
            
            // Not worth instancing, too heterogeneous and small
            #if defined(POINT) || defined(POINT_COOKIE)
            unity_pixel_point_light(stream, _LightColor0.rgb, _WorldSpaceLightPos0.xyz, unity_WorldToLight); // 14 vertex
            #elif defined(DIRECTIONAL) || defined(DIRECTIONAL_COOKIE)
            unity_directional_light(stream, _LightColor0.rgb, -_WorldSpaceLightPos0.xyz); // 10 vertex
            #elif defined(SPOT)
            unity_spot_light(stream, _LightColor0.rgb, _WorldSpaceLightPos0.xyz, unity_WorldToLight); // 20 vertex
            #endif
        }

        ///////////////////////////////////////////////////////////////////////
        // Surface functions

        static const uint sphere_subdivision = 4;

        void instanced_draw_sphere(inout TriangleStream<Sphere> stream, Sphere sphere, uint instance, float3 center, float radius, float4 rotation) {
            // nb instances = 6 * sphere_subdivision
            // 6 faces, <subdiv> strips of <subdiv> quads for a cube-topology sphere.
            uint face_id = instance / sphere_subdivision; // [0, 6[
            uint main_axis_id = face_id >= 3 ? face_id - 3 : face_id; // 0,1,2
            float strip_id = instance - sphere_subdivision * face_id; // [0, subdiv[
            // Select axis for the face construction. normal is always active, and uv go from [-1, 1]
            float3 normal = main_axis_id == uint3(0, 1, 2) ? (face_id >= 3 ? -1 : 1) : 0; // 6 orientations
            float3 axis_u = main_axis_id == uint3(2, 0, 1) ? 1 : 0; // Any other axis
            float3 axis_v = cross(normal, axis_u); // Last vector, use cross for consistent triangle winding
            // Strip along v
            float3 a_u_normal_components = normal + lerp(-axis_u, axis_u, strip_id / float(sphere_subdivision));
            float3 b_u_normal_components = normal + lerp(-axis_u, axis_u, (strip_id + 1) / float(sphere_subdivision));
            stream.RestartStrip();
            for(uint i = 0; i <= sphere_subdivision; i += 1) {
                float3 v_component = lerp(-axis_v, axis_v, i / float(sphere_subdivision));
                sphere.normal = normalize(a_u_normal_components + v_component);
                sphere.position = UnityWorldToClipPos(center + LV_MultiplyVectorByQuaternion(sphere.normal * radius, rotation));
                stream.Append(sphere);
                sphere.normal = normalize(b_u_normal_components + v_component);
                sphere.position = UnityWorldToClipPos(center + LV_MultiplyVectorByQuaternion(sphere.normal * radius, rotation));
                stream.Append(sphere);
            }
        }
        void instanced_draw_sphere(inout TriangleStream<Sphere> stream, uint mode, uint instance_0_24, float3 center, float radius) {
            Sphere sphere;
            UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(sphere);
            sphere.mode = mode;
            sphere.spot_tan_angle = 0;
            instanced_draw_sphere(stream, sphere, instance_0_24, center, radius, float4(0, 0, 0, 1));
        }

        uniform Texture2DArray _UdonPointLightVolumeTexture;
        uniform SamplerState sampler_UdonPointLightVolumeTexture;
        uniform float _UdonPointLightVolumeCubeCount; // Cubemaps count in the custom textures array

        float4 LV_SampleCubemapArray(uint id, float3 dir) {
            float3 absDir = abs(dir);
            float2 uv;
            uint face;
            if (absDir.x >= absDir.y && absDir.x >= absDir.z) {
                face = dir.x > 0 ? 0 : 1;
                uv = float2((dir.x > 0 ? -dir.z : dir.z), -dir.y) * rcp(absDir.x);
            } else if (absDir.y >= absDir.z) {
                face = dir.y > 0 ? 2 : 3;
                uv = float2(dir.x, (dir.y > 0 ? dir.z : -dir.z)) * rcp(absDir.y);
            } else {
                face = dir.z > 0 ? 4 : 5;
                uv = float2((dir.z > 0 ? dir.x : -dir.x), -dir.y) * rcp(absDir.z);
            }
            float3 uvid = float3(uv * 0.5 + 0.5, id * 6 + face);
            return _UdonPointLightVolumeTexture.SampleLevel(sampler_UdonPointLightVolumeTexture, uvid, 0);
        }

        half4 fragment_triangles (Sphere sphere) : SV_Target {
            UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(sphere);
            const float3 normal = normalize(sphere.normal);
            const uint texture_id = sphere.mode >> 3;

            switch(sphere.mode & 0x7) {
                case 0: return half4(ShadeSH9(float4(normal, 1)), 1);
                case 1: return half4(DecodeHDR(UNITY_SAMPLE_TEXCUBE_LOD(unity_SpecCube0, normal, 0), unity_SpecCube0_HDR), 1);
                case 2: return half4(DecodeHDR(UNITY_SAMPLE_TEXCUBE_SAMPLER_LOD(unity_SpecCube1, unity_SpecCube0, normal, 0), unity_SpecCube1_HDR), 1);
                case 3: {
                    // From LV_SphereSpotLightCookie
                    float2 uv = normal.xy * rcp(normal.z * sphere.spot_tan_angle);
                    if(normal.z <= 0 || any(abs(uv) > 1)) { return half4(0, 0, 0, 1); } // Spot projection culling
                    float3 uvid = float3(uv * 0.5 + 0.5, texture_id);
                    return _UdonPointLightVolumeTexture.SampleLevel(sampler_UdonPointLightVolumeTexture, uvid, 0);
                }
                case 4: return LV_SampleCubemapArray(texture_id, -normal);
                default: return half4(0, 0, 0, 1);
            }
        }

        [instance(6 /*faces*/ * sphere_subdivision)]
        [maxvertexcount(((sphere_subdivision + 1) * 2) /*1 strip*/ * (3 /*unity spheres*/ + 8 /*max LV spheres*/))]
        void geometry_triangles_base(point MeshData input[1], uint primitive_id : SV_PrimitiveID, uint instance : SV_GSInstanceID, inout TriangleStream<Sphere> stream) {
            UNITY_SETUP_INSTANCE_ID(input[0]);

            if (!(_VRChatMirrorMode == 0 && primitive_id == 0 && within_distance_limit())) { return; }

            if(_LightProbe_Radius > 0) {
                instanced_draw_sphere(stream, 0, instance, item_anchor_point_ws(), _LightProbe_Radius); // Light Probe
            }
            if(_ReflectionProbe_Radius > 0) {
                instanced_draw_sphere(stream, 1, instance, unity_SpecCube0_ProbePosition, _ReflectionProbe_Radius);
                #if defined(UNITY_SPECCUBE_BLENDING) || defined(FORCE_BOX_PROJECTION)
                [branch] if (unity_SpecCube0_BoxMin.w < 0.99999) {
                    instanced_draw_sphere(stream, 2, instance, unity_SpecCube1_ProbePosition, _ReflectionProbe_Radius);
                }
                #endif
            }

            const uint point_light_volume_count = min((uint) _UdonPointLightVolumeCount, 128);
            [loop] for(uint light_id = 0; light_id < point_light_volume_count; light_id += 1) {
                const float3 custom_id_data = _UdonPointLightVolumeCustomID[light_id];
                [branch] if(custom_id_data.x < 0) {
                    // Light with cookie to display. Use a sphere for both.
                    const float4 position = _UdonPointLightVolumePosition[light_id];
                    const float4 rotation = _UdonPointLightVolumeDirection[light_id]; // Always a rotation for texture cases
                    Sphere sphere;
                    UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(sphere);
                    if(position.w < 0) {
                        // spot light cookie
                        const uint texture_id = _UdonPointLightVolumeCubeCount * 5 - custom_id_data.x - 1;
                        sphere.mode = 3 | (texture_id << 3);
                        sphere.spot_tan_angle = _UdonPointLightVolumeColor[light_id].w;
                    } else {
                        // point light cubemap
                        const uint texture_id = -custom_id_data.x - 1;
                        sphere.mode = 4 | (texture_id << 3);
                        sphere.spot_tan_angle = 0;
                    }
                    instanced_draw_sphere(stream, sphere, instance, position.xyz, _Light_Radius, float4(rotation.xyz, -rotation.w));
                }
            }
        }

        ENDCG

        // TODO Maybe consider add-pass cookies : spot, point. They seem difficult to use, and rarely used, so for now avoid them.

        ///////////////////////////////////////////////////////////////////////
        // Assemble all passes

        Pass {
            Name "Base Lighting Visible Lines"
            Tags { "LightMode" = "ForwardBase" }

            ZTest LEqual

            CGPROGRAM
            #pragma vertex vertex_stage
            #pragma geometry geometry_lines_base
            #pragma fragment fragment_lines_visible
            #pragma multi_compile_instancing
            ENDCG
        }
        Pass {
            Name "Additive Lighting Visible Lines"
            Tags { "LightMode" = "ForwardAdd" }

            ZTest LEqual

            CGPROGRAM
            #pragma vertex vertex_stage
            #pragma geometry geometry_lines_add
            #pragma fragment fragment_lines_visible
            #pragma multi_compile_instancing
            #pragma multi_compile_fwdadd
            ENDCG
        }
        Pass {
            Name "Base Lighting Spheres"
            Tags { "LightMode" = "ForwardBase" }

            ZTest LEqual

            CGPROGRAM
            #pragma vertex vertex_stage
            #pragma geometry geometry_triangles_base
            #pragma fragment fragment_triangles
            #pragma multi_compile_instancing
            ENDCG
        }
        Pass {
            Name "Base Lighting Occluded Lines"
            Tags { "LightMode" = "ForwardBase" }

            ZTest Greater
            Blend SrcAlpha OneMinusSrcAlpha
            ZWrite Off

            CGPROGRAM
            #pragma vertex vertex_stage
            #pragma geometry geometry_lines_base
            #pragma fragment fragment_lines_occluded
            #pragma multi_compile_instancing
            ENDCG
        }
        Pass {
            Name "Additive Lighting Occluded Lines"
            Tags { "LightMode" = "ForwardAdd" }

            ZTest Greater
            Blend SrcAlpha OneMinusSrcAlpha
            ZWrite Off

            CGPROGRAM
            #pragma vertex vertex_stage
            #pragma geometry geometry_lines_add
            #pragma fragment fragment_lines_occluded
            #pragma multi_compile_instancing
            #pragma multi_compile_fwdadd
            ENDCG
        }
    }
}
